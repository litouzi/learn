## 数据结构

> 数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。
>
> 简单来说，数据结构就是设计数据以何种方式组织并存储在计算机中。
>
> 比如：列表、集合与字典等都是一种数据结构。
>
> N.Wirth："程序=数据结构＋算法"
>

### 数据结构的分类

> 数据结构按照其逻辑结构(还有物理结构)可分为线性结构、树结构、图结构
>
>> 线性结构：数据结构中的元素存在一对一的相互关系
>>
>> 树结构：数据结构中的元素存在一对多的相互关系
>>
>> 图结构：数据结构中的元素存在多对多的相互关系
>>
>



### 列表/数组

#### 列表

> 列表（其他语言称数组）是一种基本数据类型。
>
> 关于列表的问题：
>
>> 列表中的元素是如何存储的？(见python)
>>
>> 列表的基本操作：按下标查找、插入元素、删除元素......
>>
>> 这些操作的时间复杂度是多少？(查找O(1)  插入和删除O(n)  # 插入把元素往后挪 删除把元素往前挪)
>>
>
> 扩展：Python的列表是如何实现的？
>


#### Python列表特点

> 列表中的元素是顺序存储，有一块连续的内存
>
> 列表中存的不是真实的值，而是对应值的地址
>
> 	(32位机器上：一个整数占4字节，一个地址也占固定的4字节)
>
> 	(64位机器上：一个地址占固定的8字节)
>
> 可以存储不同类型的元素
>
> 列表长度不固定(不够用了再自动分配 复制粘贴到新的地方扩建)
>


#### 数组特点

> 数组中的元素是顺序存储，有一块连续的内存
>
> 数组只能存储单一类型的元素
>
> 数组长度固定
>
> 查找元素的时间复杂度是O(1)  # a[2]
>


#### 列表和数组的差别

> 数组元素类型要相同 列表元素类型可以不一样
>
> 数组长度固定 列表长度不固定
>



### 栈

> 栈(Stack)是一个数据集合，可以理解为只能在一端进行插入或删除操作的列表(弹夹)
>
> 栈的特点：后进先出LIFO （last-in，first-out）
>
> 栈的概念：栈顶(表尾)，栈底(表头)
>
> 栈的基本操作
>
>> 进栈(压栈)：push
>>
>> 出栈(弹栈)：pop
>>
>> 取栈顶：gettop
>>
>


#### 栈的实现

> 使用一般的列表结构即可实现栈
>
>> 进栈:li.append
>>
>> 出栈:li.pop
>>
>> 取栈顶:li[-1]
>>
>
>> ![2AD8EFBC2880A22C67116D8411F5D123.jpg](assets/2AD8EFBC2880A22C67116D8411F5D123-20220124192314-bl98iq7.jpg)
>>
>
> ```python
> class Stack:
>     def __init__(self):
>         self.stack = []
>
>     def push(self,element):  # 压栈
>         self.stack.append(element)
>
>     def pop(self):  # 弹栈
>         return self.stack.pop()
>
>     def get_top(self):  # 取栈顶
>         if len(self.stack) > 0:
>             return self.stackk[-1]
>         else:
>             return None
>     def is_empty(self):  # 栈为空
>         return len(self.stack) == 0
>
>
> stack = Stack()
> stack.push(1)
> stack.push(2)
> stack.push(3)
> print(stack.pop())
> ```
>


#### 栈的应用——括号匹配问题

> 括号匹配问题：给一个字符串，其中包括小括号、中括号、大括号，求该字符串中的括号是否匹配。
>
> 例如：
>
>> ()()[]{}    匹配
>>
>> ([{()}])    匹配
>>
>> [ ](        不匹配
>>
>> [(])        不匹配
>>
>> ```python
>> def brace_match(s):  # 括号匹配
>>     match = {')':'(',']':'[','}':'{'}  # 字典
>>     stack = Stack()
>>     for ch in s:
>>         if ch in{'(','[','{'}:  # 让所有左括号进栈
>>             stack.push(ch)
>>         else:  #ch in {'}',']',')'} 是右括号
>>             if stack.is_empty():  # 栈为空 没有与这个右括号相匹配的左括号 报错
>>                 return False
>>             elif stack.get_top() == match[ch]:  # 栈不为空 栈顶的左括号与这个右括号匹配 弹出匹配的左括号
>>                 stack.pop()
>>             else: #stack.get_top() != match[ch]  # 栈不为空 但是栈顶的括号不匹配 报错
>>                 return False
>>     if stack.is_empty(): # 最后进栈的左括号都匹配到右括号弹出 栈为空
>>         return True
>>     else:
>>         return False
>>
>> print(brace_match('[{()}(){()}[]({}){}]'))
>> print(brace_match('[{]}'))
>> ```
>>
>



### 队列

> 队列(Queue)是一个数据集合，仅允许在列表的一段进行插入，另一端进行删除。
>
> 进行插入的一端称为队尾(rear)，插入的动作称为进队或入队
>
> 进行删除的一段称为队头(front)，删除动作称为出队
>
> 队列的性质：先进先出(First-in,First-out) (尾进头出)
>


#### 队列的实现

> 队列不能用列表简单实现(进行出队时 整体元素会移动 时间复杂度O(n)太高 移动头会产生大量浪费空间)
>
>> ![02F3BF31D9C5A945DD04EF8D8B4CECBF.png](assets/02F3BF31D9C5A945DD04EF8D8B4CECBF-20220124190953-z5ghov7.png)
>>
>
> 环形队列:
>
>> ![557DB43DA7706D406A2D75BDCF86E996.jpg](assets/557DB43DA7706D406A2D75BDCF86E996-20220124191312-jlw47k0.jpg)
>>
>>
>
>> 队列的实际大小为12 最大存11个元素(Maxsize)
>>
>> 新加法形成闭环 11+1＝0
>>
>> 队空时rear=front
>>
>> 队满rear+1=front时留一个空避免混淆
>>
>> 进队时rear尾+1指向那个进来的元素
>>
>> 出队时front头+1指向离开的那个元素留下的新的空位
>>
>
> 环形队列：当尾指针front==Maxsize + 1时，再前进一个位置就自动到0
>
>> 队首指针前进1：front = (front + 1) % MaxSize  #避免超出大小 形成闭环 
>>
>> 队尾指针前进1：rear = (rear + 1) % MaxSize
>>
>> 队空条件：rear == front
>>
>> 队满条件：(rear + 1)%MaxSize == front
>>
>
> ```python
> class Queue:
>     def __init__(self,size = 100):  # 创建列表时需要先确定最大值Maxsize
>         self.queue = [0 for _ in range(size)]
>         self.size = size
>         self.rear = 0  # 队尾指针
>         self.front = 0  # 队首指针
>
>     def push(self, element):  # 进队 可能导致队满
>         if not self.is_filled():  # 队不满 可以进队
>             self.rear = (self.rear + 1) % self.size # 将尾向前移动1
>             self.queue[self.rear] = element  # 使进入的新值处于尾新指向的位置
>         else:  # 队满 无法进队
>             raise IndexError("Queue is filled.")
>
>     def pop(self):  # 出队 可能导致队空
>         if not self.is_empty():  # 队不空 可以出队
>             self.front = (self.front + 1) % self.size  # 将头向前移动1指向要出去的值(原本front指向空)
>             return self.queue[self.front]  # 取得此处的值
>         else:  # 队空 无法出队
>             raise IndexError("Queue is empty.")
>   
>     def is_empty(self):  # 队空
>         return self.rear == self.front #头尾指针指向相同时返回队空true
>
>     def is_filled(self):  # 队满
>         return (self.rear + 1) % self.size == self.front
>
> q = Queue(5)  # 创建一个长度5(实际占空间6 能存5个值)的(环形)队列
> for i in range(4):
>     q.push(i)
> print(q.pop())
> q.push(4)
> ```
>


#### 双向队列

> 双向队列的两端都支持进队和出队操作
>
> 双向队列的基本操作:
>
>> 队首进队
>>
>> 队首出队
>>
>> 队尾进队
>>
>> 队尾出队
>>
>


#### Python队列内置模块

> 使用方法：from collections import deque
>
>> 创建队列：queue = deque()
>>
>> 进队：append()  # 尾进
>>
>> 出队：popleft()  # 头出
>>
>> 双向队列队首进队：appendleft()  # 头进
>>
>> 双向队列队尾出队：pop()  # 尾出
>>
>> (left头(在左边))默认对尾操作 加left为对头操作
>>
>
> ```python
> from collections import deque  # de双向queue队列
>
> q = deque([1,2,3], 5)  # 创建含初始值的队列 长度为5(队满会自动出队) (left头end尾)
> q.append(4)  # 队尾进队
> print(q.popleft())  # 队首出队
>
> # # 用于双向队列
> # q.appendleft(1)  # 队首进队
> # q.pop()  # 队尾出队
> ```
>



### 栈和队列的应用——迷宫问题

> 给一个二维列表，表示迷宫(上下左右四向)（0表示通道，1表示围墙）。给出算法，求一条走出迷宫的路径。4
>
>> ![667962BD1A3040F65E963B6B21B9CCC6.jpg](assets/667962BD1A3040F65E963B6B21B9CCC6-20220124202902-a8phdtd.jpg)![2D59C96F6C1277DC349514517B86271F.jpg](assets/2D59C96F6C1277DC349514517B86271F-20220124202930-n065vy0.jpg)
>>
>> 走的路不重复交叉 (走过则置为标记 1为墙 可置为2区分标记)
>>
>

#### 使用栈进行迷宫问题

#### 栈——深度优先搜索

> 回溯法
>
> 思路：从一个结点开始，任意找(任意规定查找顺序 上下左右)下一个能走的点(压栈 往深处走)，当找不到能走的点时，退回上一个点(弹栈)寻找是否有其他方向的点。 若退回到栈为空 表示没有线路连接起点终点
>
> 使用栈存储**当前路径**
>
> ```python
> maze = [
>     [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
>     [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
>     [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
>     [1, 0, 0, 0, 0, 1, 1, 0, 0, 1],
>     [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],
>     [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
>     [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
>     [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
>     [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
>     [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
> ]
>
> dirs = [  # 用一个列表封装四个方向
>     lambda x,y: (x+1,y),  # 下
>     lambda x,y: (x-1,y),  # 上
>     lambda x,y: (x,y+1),  # 右
>     lambda x,y: (x,y-1),  # 左
> ]
>
> def maze_path(x1,y1,x2,y2):  # (x1,y1)起点位置(元组) (x2,y2)终点位置 x行标 y列标
>     stack = []
>     stack.append((x1, y1))
>     while(len(stack)>0):  # 栈不为空 有路时寻路
>
>         curNode = stack[-1]  # 当前结点
>         if curNode[0] == x2 and curNode[1] == y2:  #走到终点了
>             for p in stack:  # 输出路径 游历一遍栈
>                 print(p)
>             return True  # 寻路成功
>
>         #(x,y)四个方向 上(x-1,y) 下(x+1,y) 左(x,y-1) 右(x,y+1)
>         for dir in dirs:  # 找四个方向能不能走
>             nextNode = dir(curNode[0],curNode[1])  # 将当前点curNode的坐标传进dirs进行四向循环
>           
>             # 如果下一个结点能走
>             if maze[nextNode[0]][nextNode[1]] == 0:  # 通路
>                 stack.append(nextNode)  # 把将要走过的路加到栈里面 走过去了 此时curNode = stack[-1]  # 当前结点 和nextNode相等
>                 maze[nextNode[0]][nextNode[1]] = 2  # 用2标记走过的路
>                 break  # 能找到一个就break 走过去
>
>         else:  # 对于for 找不到通路 都是死路(墙或已走过的路)
>             maze[nextNode[0]][nextNode[1]] = 2  # 无路走时也将此结点置2 (至少对于起点 将起点置2弹出去 变为空栈)
>             stack.pop()  # 出栈 退回去
>
>     else:  # while跳出 栈为空 没路
>         print("没有路")
>         return False
>
> maze_path(1,1,8,8)  # 起点(1,1)终点(8,8)迷宫问题
> ```
>


#### 使用队列进行迷宫问题

#### 队列——广度优先搜索

> 思路：从一个节点开始，寻找**所有**接下来能继续走的点，继续不断寻找，直到找到出口
>
> 使用队列存储**当前正在考虑的结点** (入队)    (树叶)
>
> 额外的列表(两行 上行存路径点 下行存对应的路径点由前一个路径点走来的前一个路径点的位置 不存在(起点的前一个点)可以置为-1 起点为0 依次为1, 2，3...} 存路径(元素出队的序列)     (树)
>
>
>> 如 1    2    3    4    5    6    7
>>
>>    -1    0    1    2    2    3    4  这个额外列表  从终点遍历所有祖先结点得到路径
>>
>
>> ![D88FC29F451A25754DCA7B456AE0DAB3.jpg](assets/D88FC29F451A25754DCA7B456AE0DAB3-20220124221916-oiwrvbu.jpg)![2D59C96F6C1277DC349514517B86271F.jpg](assets/2D59C96F6C1277DC349514517B86271F-20220124202930-n065vy0.jpg)
>>
>
>> ![4C396E739BB3DA3726A968CB4A060408.png](assets/4C396E739BB3DA3726A968CB4A060408-20220124225817-zproc40.png)
>>
>
> 图中A1,A2,A3的位置为当前path列表长度-1(列表把值出队给curNode的次数-1)(级数)
>
>       加入队列时就定好位置了 而不是加入path时
>
>> ```python
>> from collections import deque
>> from os import curdir  # 使用现成队列
>>
>> maze = [
>>     [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
>>     [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
>>     [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
>>     [1, 0, 0, 0, 0, 1, 1, 0, 0, 1],
>>     [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],
>>     [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
>>     [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
>>     [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
>>     [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
>>     [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
>> ]
>>
>> dirs = [  # 用一个列表封装四个方向
>>     lambda x,y: (x+1,y),  # 下
>>     lambda x,y: (x-1,y),  # 上
>>     lambda x,y: (x,y+1),  # 右
>>     lambda x,y: (x,y-1),  # 左
>> ]
>>
>> def print_r(path):  # 通过全部路径path输出真正路径realpath
>>     curNode = path[-1]  # 将结点放在最后的那个值 [-1]取最后的元素
>>
>>     realpath = []  # 用一个列表存储真正通路的路径
>>
>>     while curNode[2] != -1:  # 没有游历完所有祖先 没有回到起点 从最后一个元素开始找真正路径
>>         realpath.append((curNode[0], curNode[1]))  # realpath.append((curNode[0:2]) 将结点加入真正路径
>>         curNode = path[curNode[2]]  # 上一个点由这一个点的位置找出  
>>
>>     realpath.append(curNode[0:2])  # 把循环完之后的当前结点(起点)加入真正路径列表
>>     realpath.reverse()  # 倒序
>>     for node in realpath:  # 循环输出路径
>>         print(node)
>>
>> def maze_path_queue(x1,y1,x2,y2):
>>     queue = deque()  # 创建一个队列用来存当前考虑的结点
>>     queue.append((x1, y1, -1))  # 添加起点 三元元组 存了结点坐标和前一个结点的列表位置
>>     path = []  # 额外的列表
>>     while len(queue) > 0:  # 只要列表不为空 就有路可寻
>>
>>         curNode = queue.popleft()  # 把队列元素出队到当前结点 起点不考虑了 变为走过的路径 考虑下一步的结点
>>         path.append(curNode)  #将当前判断(走上去的点加入额外的列表 记录路径) 
>>         if curNode[0] == x2 and curNode[1] == y2:  # 找到终点 输出所有路径
>>             print_r(path)
>>             return True
>>
>>         for dir in dirs:  # 在当前结点的上下左右寻路
>>             nextNode = dir(curNode[0], curNode[1])
>>             if maze[nextNode[0]][nextNode[1]] == 0:  # 通路
>>                 queue.append((nextNode[0],nextNode[1], len(path)-1))  # 则把新的结点加入队列 变为当前要考虑的结点 位置为path的长度-1
>>                 #此处不break 因为不是找到一个可行结点就往里走(深度) 而是找出此处的所有可行结点放入队列(广度)
>>                 #找完所有当前要考虑的结点之后 依次弹出当前要考虑的结点到当前结点curNode再往下进行寻路
>>                 maze[nextNode[0]][nextNode[1]] = 2  # 将新的结点(将要用line29 curNode = queue.pop()走上去的结点)(树叶)置2
>>     else:  # while跳出 无路可寻
>>         print("没有路")
>>         return False
>>
>> maze_path_queue(1,1,8,8)
>>
>>
>>
>>
>> ```
>>
>


### 链表

> 链表是由一系列结点组成的元素集合。每个结点包含两部分，数据域item和指向下一个结点的指针next。通过节点之间的相互连接，最终串联成一个链表。
>
> ```python
> class Node(object):
>     def __int__(self,item):
>         self.item = item
>         self.next = None
>
> a = Node(1)  # 指向
> b = Node(2)
> c = Node(3)
> a.next = b
> b.next = c
>
> print(a.next.next.item)
> ```
>
> 链表元素地址可不连续
>


#### 创建链表

> 头插法：新的结点指向旧的头 且新结点成为新的头
>
> ```python
> def create_linklist_head(li):  # 头插法
>     head = Node(li[0])  # 根据第一个结点创建头结点
>     for element in li[1:]:
>         node = Node(element)  # 在循环中创建一个新的结点
>         node.next = head  # 使新结点指向在它之前创建的结点
>         head = node  # 使新的结点成为新的头 (完成一个新头的插入)
>     return head
> ```
>
> 尾插法：新的结点由旧的尾所指向 且新结点成为新的尾
>
> ```python
>
> def create_linklist_tail(li):  # 尾插法
>     head = Node(li[0])  # 根据第一个结点创建头结点
>     tail = head  # 第一个头结点也是尾结点
>     for element in li[1:]:
>         node = Node(element)  # 在循环中创建一个新的结点
>         tail.next = node  # 使得尾(前一个元素)指向新的结点(下一个元素)
>         tail = node  # 使新的结点成为新的尾 (完成一个尾的插入)
>     return head  # 由于结点自身只有next 只能从头找元素
> ```
>
>  遍历：
>
> ```python
> def print_linklist(lk):  # lk为头 只要lk不为None 循环打印 遍历链表
>     while lk:
>         print(lk.item, end=',')
>         lk = lk.next
>
> lk1 = create_linklist_head([1,2,3])
> lk2 = create_linklist_tail([1,2,3,6,8])
> print_linklist(lk1)  # 3,2,1
> print_linklist(lk2)  # 1,2,3,6,8
> ```
>
